---
layout: post
title:  "PHP Design Patterns"
date:   2015-05-01 21:18:10 +0200
categories: php 
tags: php
comments: false
---


This is an abstract from the book PHP Design Patterns by Aaron Saray. I found it very useful, explanations are clear and simple and it has code examples which is always nice. I consider knowing this of a great importance, because as the business logic grows no matter of your framework you have to code your own framework. There are many frameworks out there today, but they can be nothing more than a good basic to start of your application, otherwise we're stuck with large and unmaintainable code. Below is copy/paste of the main headers from the book so I can read it from time to time. 

1. The Adapter Design Pattern simply adapts one object’s interfaces to what another object expects. 

2. The Builder Design Pattern defines the design of an object that handles the complex building of another object. 

3. The Data Access Object Design Pattern describes the creation of an object that provides trans-parent access to any data source. 

4. The Decorator Design Pattern is best suited for altering or decorating portions of an existing object’s content or functionality without modifying the structure of the original object. 

5. The Delegate Design Pattern removes decisions and complex functionality from the core object by distributing or delegating them to other objects. 

6. The Façade Design Pattern hides complexity from a calling object by creating a simple façade interface in front of the collection of required logic and methods. 

7. The Factory Design Pattern provides a simple interface to acquire a new instance of an object, while sheltering the calling code from the steps to determine which base class is actually instantiated. 

8. The Interpreter Design Pattern analyzes an entity for key elements and provides its own interpretation or action corresponding to each key. 

9. The Iterator Design Pattern helps construct objects that can provide a single standard inter-face to loop or iterate through any type of countable data. 

10. The Mediator Design Pattern is used to develop an object that communicates or mediates changes to a collection of similar objects without them interacting with each other directly. 

11. The Observer Design Pattern facilitates the creation of objects that watch the state of a target object and provides state targeted functionality that is uncoupled from the core object. 

12. The Prototype Design Pattern creates objects in such a way that an initial object or prototype can be copied and cloned more efficiently than creating a new instance. 

13. The Proxy Design Pattern builds an object that is positioned transparently within two other objects in order to intercept or proxy the communication or access. 

14. The Singleton Design Pattern is used to restrict the number of times a specific object can be created to a single time by providing access to a shared instance of itself. 

15. The Strategy Design Pattern helps architect an object that can make use of algorithms in other objects on demand in lieu of containing the logic itself. 

16. The Template Design Pattern creates an abstract object that enforces a set of methods and functionality that will be used in common by child classes as a template for their own design. 

17. The Visitor Design Pattern constructs distinct objects containing an algorithm that, when consumed by a parent object in a standard way, apply that algorithm to the parent object.